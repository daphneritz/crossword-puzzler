/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package game.template;

import java.net.URL;
import java.util.ArrayList;
import java.util.Stack;
import java.util.HashMap;
import java.util.Map;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.control.Menu;
import javafx.scene.control.MenuBar; 
import javafx.scene.control.MenuItem;
import javafx.scene.control.TextField;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;
import javafx.stage.FileChooser;
import javafx.scene.control.Alert;
import javafx.scene.control.Alert.AlertType;
import javafx.scene.control.Button;
import javafx.scene.layout.HBox;
import javafx.scene.control.ScrollPane; 
import javafx.scene.layout.Priority;
import javafx.scene.layout.StackPane;
import javafx.scene.control.Label;
import javafx.scene.control.ListView; 
import javafx.collections.ObservableList;
import javafx.collections.FXCollections;
import javafx.scene.text.Text;
import javafx.scene.text.TextFlow;





import java.io.File;
import java.io.FileInputStream;


public class Main extends Application
{
    private Grid grid=new Grid(); 
    private static final int NUM_ROWS = 5;
    private static final int NUM_COLS = 5;
    private VBox root;
    private HBox clues;
    private TextField[][] textFields = new TextField[NUM_ROWS][NUM_COLS];
    private int[][] cellNumbers = new int[NUM_ROWS][NUM_COLS];
    private boolean loadingBoard=false; 
    private Stage primaryStage;
    private boolean horizontal=true;
    private boolean ignore=false;  
    private Direction currentDirection; 
    private Map<Integer, String> acrossClues=new HashMap<Integer, String>();
    private Map<Integer, String> downClues=new HashMap<Integer, String>();
    

    @Override
    public void start(Stage primaryStage) throws Exception
    {
        this.primaryStage = primaryStage;
        primaryStage.setTitle("Crossword Puzzler"); 

        showMainMenu(); 
    }

    private void showMainMenu(){
        VBox menuLayout = new VBox(10);
        menuLayout.setStyle("-fx-alignment: center; -fx-padding: 20;");

        Button createButton = new Button("Create a Crossword");
        createButton.getStyleClass().add("button"); 

        Button playButton = new Button("Play a Crossword");
        playButton.getStyleClass().add("button");

        createButton.setOnAction(e -> showCreateCrosswordScene());
        playButton.setOnAction(e -> showPlayCrosswordScene());

        menuLayout.getChildren().addAll(createButton, playButton);
        Scene mainMenuScene = new Scene(menuLayout, 300, 200);

        primaryStage.setScene(mainMenuScene);
        primaryStage.show();
    }

    private void showCreateCrosswordScene(){
        System.out.println("Create a Crossword");
        root = new VBox();

        root.getChildren().add(createMenuBar());

        GridPane gridPane = new GridPane();
        root.getChildren().add(gridPane); 
        gridPane.getStyleClass().add("grid-pane");

        for (int row = 0; row < NUM_ROWS; row++)
        {
            for (int col = 0; col < NUM_COLS; col++)
            {
                
                textFields[row][col] = new TextField();
                TextField textField = textFields[row][col];
                
                StackPane cellPane = new StackPane();
                cellPane.getChildren().add(textField);
                
                gridPane.add(cellPane, col, row);


                // 5 rows, 5 columns for crossword
                textField.setId(row + "-" + col);
                // add highlight when textField is clicked 
                textField.setOnMouseClicked(event -> {
                    TextField newField=(TextField)event.getSource();
                    specialFocus(newField);
                    newHighlight(newField);

                });

                // highlight first row 
                if (row==0){
                    textField.getStyleClass().add("row-highlight");
                    if (col==0){
                        textField.getStyleClass().remove("row-highlight");
                        textField.getStyleClass().add("text-field-selected");
                    }
                }


                // add right click listener to toggle black square
                textField.setOnContextMenuRequested(event ->{
                    String id = textField.getId();
                    String[] parts = id.split("-");
                    int r = Integer.parseInt(parts[0]);
                    int c = Integer.parseInt(parts[1]);
                
                    if (textField.getStyleClass().contains("black-square")){
                        // if black square, remove 
                        textField.getStyleClass().remove("black-square");
                        // set grid to empty string
                        grid.setCell(r, c, "");
                    } else {
                        /// if not black square, add
                        textField.getStyleClass().add("black-square");
                        // set grid to "+"
                        grid.setCell(r, c, "+");
                    }
                    // if now a black square and was selected, move to next square 
                    if (textField.getStyleClass().contains("text-field-selected")){
                        // remove highlight from current square
                        // maybe actually don't need to do this but it works and i am scared to touch anything that works
                        textField.getStyleClass().remove("text-field-selected");
                        TextField nextSquare=getNextCell(r, c);
                        specialFocus(nextSquare);
                        newHighlight(nextSquare);
                    }
                    updateBoard(); 
                }); 
                
                // add backspace listener to delete letter, if empty, move highlight to prev square 
                
                textField.setOnKeyPressed(event ->{
                    System.out.println("Key pressed: " + event.getCode());
                    StackPane parentNode=(StackPane)textField.getParent();
                    int currRow=GridPane.getRowIndex(parentNode);
                    int currCol=GridPane.getColumnIndex(parentNode); 
                
                    switch (event.getCode()){
                        case BACK_SPACE: 
                            String id = textField.getId();
                            String[] parts = id.split("-");
                            int r = Integer.parseInt(parts[0]);
                            int c = Integer.parseInt(parts[1]);
                    
                            // Clear the current cell
                            if (!textField.getText().equals("")){
                                textField.setText("");
                                grid.setCell(r, c, "");
                                updateBoard(); 
                            } 
                    
                            // Move to the previous cell
                            TextField previousSquare = getPrevCell(r, c);
                            specialFocus(previousSquare);
                            newHighlight(previousSquare);

                            event.consume();
                            break; 
                        
                        case UP:
                            if(currRow > 0){
                                currRow--;
                                while (currRow >= 0 && textFields[currRow][currCol].getStyleClass().contains("black-square")){
                                    currRow--;
                                }
                                if (currRow >= 0) {
                                    TextField a = textFields[currRow][currCol];
                                    currentDirection = Direction.UP;
                                    specialFocus(a);
                                    newHighlight(a);
                                }
                            }
                            break;
                        case DOWN:
                            if(currRow < NUM_ROWS - 1){
                                currRow++;
                                while (currRow < NUM_ROWS && textFields[currRow][currCol].getStyleClass().contains("black-square")){
                                    currRow++;
                                }
                                if (currRow < NUM_ROWS) {
                                    TextField a = textFields[currRow][currCol];
                                    currentDirection = Direction.DOWN;
                                    specialFocus(a);
                                    newHighlight(a);
                                }
                            }
                            break;
                        case LEFT:
                            if(currCol > 0){
                                currCol--;
                                while (currCol >= 0 && textFields[currRow][currCol].getStyleClass().contains("black-square")){
                                    currCol--;
                                }
                                if (currCol >= 0) {
                                    TextField a = textFields[currRow][currCol];
                                    currentDirection = Direction.LEFT;
                                    specialFocus(a);
                                    newHighlight(a);
                                }
                            }
                            break;
                        case RIGHT:
                            if(currCol < NUM_COLS - 1){
                                currCol++;
                                while (currCol < NUM_COLS && textFields[currRow][currCol].getStyleClass().contains("black-square")){
                                    currCol++;
                                }
                                if (currCol < NUM_COLS) {
                                    TextField a = textFields[currRow][currCol];
                                    currentDirection = Direction.RIGHT;
                                    specialFocus(a);
                                    newHighlight(a);
                                }
                            }
                            break;
                        case ENTER:
                            horizontal = !horizontal;
                            changeDirHighlight(textField);
                        default:
                            break;
                    }
                });

                textField.textProperty().addListener((observable, oldValue, newValue) -> {
                   
                    // if loading board, ignore 
                    if (loadingBoard){
                        return; 
                    }
                    // only accept letters 
                    // throw exception if not a letter
                    
                    if (!newValue.matches("[a-zA-Z]*")){
                        textField.setText(oldValue);
                        return; 
                    }
                    String id = textField.getId();
                    String[] parts = id.split("-");
                    int r = Integer.parseInt(parts[0]);
                    int c = Integer.parseInt(parts[1]);
                    String value=newValue.toUpperCase(); 
                
                    if (value.isEmpty()){
                        grid.setCell(r, c, "");
                        updateBoard(); 
                    } else {
                        try{
                            System.out.println("Setting cell "+r+","+c+" to "+newValue);
                            if (!value.matches("[A-Z]")){
                                textField.setText(oldValue);
                                throw new Exception("Invalid character in grid: "+value); 
                            }
                            grid.setCell(r, c, value);
                            updateBoard();
                            // move to next square
                            TextField nextSquare=getNextCell(r, c);
                            specialFocus(nextSquare); 
                            newHighlight(nextSquare);
                        } catch (Exception e){
                            Alert alert=new Alert(AlertType.ERROR);
                            alert.setTitle("Invalid character in grid");
                            alert.setHeaderText(e.getMessage());
                            alert.setContentText(e.getMessage());
                            alert.showAndWait();  
                        }
                    }
                }); // end textfield listener



            } // end for loop 
        } // end for loop 

        setUpClueView(); 


        root.setOnKeyPressed(event -> {
            System.out.println("Key pressed: " + event.getCode());
            switch (event.getCode())
            {
                // check for the key input
                case ESCAPE:
                    // remove focus from the textfields by giving it to the root VBox
                    root.requestFocus(); 
                    System.out.println("You pressed ESC key");
                    break;
                default:
                    System.out.println("you typed key: " + event.getCode());
                    break;
                
                
            }
        });

        // don't give a width or height to the scene
        Scene scene = new Scene(root);

        URL styleURL = getClass().getResource("/style.css");
        String stylesheet = styleURL.toExternalForm();
        scene.getStylesheets().add(stylesheet);
        primaryStage.setTitle("Crossword Puzzler");
        primaryStage.setScene(scene);
        primaryStage.show();

        primaryStage.setOnCloseRequest(event -> {
            System.out.println("oncloserequest");
        });
        
    }

    private void showPlayCrosswordScene(){
        System.out.println("Play a Crossword");
     /*   root = new VBox();

        root.getChildren().add(createMenuBarPlay());

        GridPane gridPane = new GridPane();
        root.getChildren().add(gridPane);
        gridPane.getStyleClass().add("grid-pane");

        for (int row = 0; row < NUM_ROWS; row++)
        {
            for (int col = 0; col < NUM_COLS; col++)
            {
                textFields[row][col] = new TextField();
                TextField textField = textFields[row][col];
                
                // 5 rows, 5 columns for crossword
                textField.setId(row + "-" + col);
                gridPane.add(textField, col, row);
            }
        }

        root.setOnKeyPressed(event -> {
            System.out.println("Key pressed: " + event.getCode());
            switch (event.getCode())
            {
                // check for the key input
                case ESCAPE:
                    // remove focus from the textfields by giving it to the root VBox
                    root.requestFocus();
                    System.out.println("You pressed ESC key");
                    break;
                default:
                    System.out.println("you typed key: " + event.getCode());
                    break;
                
            }
        });

        // don't give a width or height to the scene
        Scene scene = new Scene(root);

        URL styleURL = getClass().getResource("/style.css");
        String stylesheet = styleURL.toExternalForm();
        scene.getStylesheets().add(stylesheet);
        primaryStage.setTitle("Crossword Puzzler");
        primaryStage.setScene(scene);
        primaryStage.show();
        */
        primaryStage.setOnCloseRequest(event -> {
            System.out.println("oncloserequest");
        });

    }

    private MenuBar createMenuBarPlay()
    {
        MenuBar menuBar = new MenuBar();
    	menuBar.getStyleClass().add("menubar");

        //
        // File Menu
        //
    	Menu fileMenu = new Menu("File");

        addMenuItem(fileMenu, "Load from file", () -> {
            System.out.println("Load from file");
            FileChooser fileChooser = new FileChooser();
            File initialDir = new File("c:\\Users\\daphn\\Documents\\crossword-puzzler\\crosswords");
            if (initialDir.exists() && initialDir.isDirectory()) {
                fileChooser.setInitialDirectory(initialDir);
            } else {
                System.out.println("Initial directory does not exist or is not a directory: " + initialDir.getAbsolutePath());
            }
            File selectedFile = fileChooser.showOpenDialog(primaryStage);
            if (selectedFile != null)
            {
                try{
                    loadingBoard=true;
                    grid=Grid.loadCrossword(new FileInputStream(selectedFile));
                    updateBoardPlay(); 
                    loadingBoard=false;
                } catch (Exception e) {
                    Alert alert=new Alert(AlertType.ERROR);
                    alert.setTitle("Unable to load crossword from "+selectedFile.getName());
                    alert.setHeaderText(e.getMessage());
                    alert.setContentText(e.getMessage());
                    if (e.getCause()!=null){
                        e.getCause().printStackTrace();
                    }
                    alert.showAndWait();  
                }
            }           
        });

        menuBar.getMenus().add(fileMenu);

        return menuBar;
    }
   
    private MenuBar createMenuBar()
    {
        MenuBar menuBar = new MenuBar();
    	menuBar.getStyleClass().add("menubar");

        //
        // File Menu
        //
    	Menu fileMenu = new Menu("File");

        addMenuItem(fileMenu, "Load from file", () -> {
            System.out.println("Load from file");
            FileChooser fileChooser = new FileChooser();
            File initialDir = new File("c:\\Users\\daphn\\Documents\\crossword-puzzler\\crosswords");
            if (initialDir.exists() && initialDir.isDirectory()) {
                fileChooser.setInitialDirectory(initialDir);
            } else {
                System.out.println("Initial directory does not exist or is not a directory: " + initialDir.getAbsolutePath());
            }
            File selectedFile = fileChooser.showOpenDialog(primaryStage);
            if (selectedFile != null)
            {
                try{
                    loadingBoard=true;
                    grid=Grid.loadCrossword(new FileInputStream(selectedFile));
                    updateBoard();
                    setUpClueView();
                    loadingBoard=false;
                } catch (Exception e) {
                    Alert alert=new Alert(AlertType.ERROR);
                    alert.setTitle("Unable to load crossword from "+selectedFile.getName());
                    alert.setHeaderText(e.getMessage());
                    alert.setContentText(e.getMessage());
                    if (e.getCause()!=null){
                        e.getCause().printStackTrace();
                    }
                    alert.showAndWait();  
                }
            }           
        });

        addMenuItem(fileMenu, "Clear Board", () -> {
            System.out.println("Clear Board");
            clearBoard();
            clearHighlights(); 
            textFields[0][0].requestFocus();
            newHighlight(textFields[0][0]);
        }); 
        
        addMenuItem(fileMenu, "Return to Main Menu", () -> {
            System.out.println("Return to Main Menu");
            showMainMenu();
        });

        menuBar.getMenus().add(fileMenu);

        return menuBar;
    }

    private void addMenuItem(Menu menu, String name, Runnable action)
    {
        MenuItem menuItem = new MenuItem(name);
        menuItem.setOnAction(event -> action.run());
        menu.getItems().add(menuItem);
    }


    private void updateBoard(){
        for (int row = 0; row < NUM_ROWS; row++)
        {
            for (int col = 0; col < NUM_COLS; col++)
            {
                if (textFields[row][col].getStyleClass().contains("black-square")){
                    textFields[row][col].getStyleClass().remove("black-square");
                }
                TextField textField = textFields[row][col];
                String value = grid.getCell(row, col);
                if (value==null){
                    value=""; 
                }
                if (!value.equals("+"))
                {
                    textField.setText(value); 
                }
                else
                {
                    textField.setText("");
                    blackOutSquare(row, col);
                }
            }
        }
        clearLabels(); 
        labelStartCells();
        clearHints(); 
        setUpClueView(); 
            
    }

    private void updateBoardPlay(){
        // update board for play mode 
        // should add black squares, should not add anything from grid 

    }

    private void blackOutSquare(int row, int col){
        TextField textField = textFields[row][col];
        textField.getStyleClass().add("black-square"); 
    }

    private void newHighlight(TextField textField){
        // find which direction highlight should go 
        if (horizontal){
            horizontalHighlight(textField); 
        } else {
            verticalHighlight(textField); 
        }
    }

    private void horizontalHighlight(TextField textField){
        StackPane parentNode=(StackPane)textField.getParent();
        int currRow=GridPane.getRowIndex(parentNode);
        int currCol=GridPane.getColumnIndex(parentNode);

        clearHighlights(); 

        textField.getStyleClass().add("text-field-selected");

        // add highlight to all textfields in the row
        // add highlights to all textfields after until a black square or end
        for (int col=currCol+1; col<NUM_COLS; col++){
            TextField a=textFields[currRow][col];
            if (a.getStyleClass().contains("black-square")){
                break; 
            }
            a.getStyleClass().add("row-highlight");
        }
        // add all highlights to textfields before until black square or end
        for (int col=currCol-1; col>=0; col--){
            TextField a=textFields[currRow][col];
            if (a.getStyleClass().contains("black-square")){
                break; 
            }
            a.getStyleClass().add("row-highlight");
        }

    }
    
    private void verticalHighlight(TextField textField){
        StackPane parentNode=(StackPane)textField.getParent();
        int currRow=GridPane.getRowIndex(parentNode);
        int currCol=GridPane.getColumnIndex(parentNode);

        clearHighlights(); 
        // add highlights to column 
        textField.getStyleClass().add("text-field-selected");
        // add highlights to all textfields after until a black square or end 
        for (int row=currRow+1; row<NUM_ROWS; row++){
            TextField a=textFields[row][currCol];
            if (a.getStyleClass().contains("black-square")){
                break; 
            }
            a.getStyleClass().add("row-highlight");
        }
        // add all highlights to textfields before until black square or end
        for (int row=currRow-1; row>=0; row--){
            TextField a=textFields[row][currCol];
            if (a.getStyleClass().contains("black-square")){
                break; 
            }
            a.getStyleClass().add("row-highlight");
        }   
    }

    private void changeDirHighlight(TextField textField){
        // tbh i think this is a vestigal method i don't think i need it anymore but i'll leave it here in memory of whatever i thought i was doing
        StackPane parentNode=(StackPane)textField.getParent();
        int currRow=GridPane.getRowIndex(parentNode);
        int currCol=GridPane.getColumnIndex(parentNode);

        clearHighlights(); 
        if (horizontal){
            horizontalHighlight(textField); 
        } else {
            verticalHighlight(textField); 
        } 

    }

    private void clearBoard(){
        // clears everything from board including highlights, black squares, hints, and anything typed
        grid.clearBoard(); 
        grid.clearHints(); 
        clearHighlights(); 
        clearHints(); 
        updateBoard(); 
    }

    private void clearHints(){
        // set all hints to empty string
        acrossClues.clear();
        downClues.clear();
        if (clues!=null){
            root.getChildren().remove(clues);
            clues=null; 
        }
    }

    private void clearHighlights(){
        // clears all highlights from board 
        for (int i=0; i<NUM_ROWS; i++){
            for (int j=0; j<NUM_COLS; j++){
                textFields[i][j].getStyleClass().remove("row-highlight");
                textFields[i][j].getStyleClass().remove("text-field-selected");
            }
        }
    }

    private TextField getPrevCell(int row, int col) {
        // no clue why i changed this from row probably don't worry about it 
        int currRow=row; 
        int currCol=col;
        // if at the top, stay there
        // i don't want to think about what you should do if you're at the [0][1] and [0][0] is a black square
        // so tbh i'm not going to 
        if (currCol==0 && currRow==0){
            return textFields[0][0]; 
        }

        if (horizontal) {
            // Move to previous column
            currCol--;
            // If at the beginning of the row, move to the last column of the previous row
            if (currCol < 0) {
                currCol = NUM_COLS - 1;
                currRow--;
                // If at the beginning of the grid, wrap around to the last row
                if (currRow < 0) {
                    currRow = NUM_ROWS - 1;
                }
            }
        } else {
            // Move to previous row
            currRow--;
            // If at the beginning of the column, move to the last row of the previous column
            if (currRow < 0) {
                currRow = NUM_ROWS - 1;
                currCol--;
                // If at the beginning of the grid, wrap around to the last column
                if (currCol < 0) {
                    currCol = NUM_COLS - 1;
                }
            }
        }
        
        // Check if the previous cell is a black square and find the previous valid cell
        while (textFields[currRow][currCol].getStyleClass().contains("black-square")) {
            if (horizontal) {
                currCol--;
                if (currCol < 0) {
                    currCol = NUM_COLS - 1;
                    currRow--;
                    if (currRow < 0) {
                        currRow = NUM_ROWS - 1;
                    }
                }
            } else {
                currRow--;
                if (currRow < 0) {
                    currRow = NUM_ROWS - 1;
                    currCol--;
                    if (currCol < 0) {
                        currCol = NUM_COLS - 1;
                    }
                }
            }
        }
    
        return textFields[currRow][currCol];
    }

    private TextField getNextCell(int row, int col) {
        if (horizontal) {
            // Move to next column
            col++;
            // If at the end of the row, move to the first column of the next row
            if (col == NUM_COLS) {
                col = 0;
                row++;
                // If at the end of the grid, wrap around to the first row
                if (row == NUM_ROWS) {
                    row = 0;
                }
            }
        } else {
            // Move to next row
            row++;
            // If at the end of the column, move to the first row of the next column
            if (row == NUM_ROWS) {
                row = 0;
                col++;
                // If at the end of the grid, wrap around to the first column
                if (col == NUM_COLS) {
                    col = 0;
                }
            }
        }
        
        // Check if the next cell is a black square and find the next valid cell
        while (textFields[row][col].getStyleClass().contains("black-square")) {
            if (horizontal) {
                col++;
                if (col == NUM_COLS) {
                    col = 0;
                    row++;
                    if (row == NUM_ROWS) {
                        row = 0;
                    }
                }
            } else {
                row++;
                if (row == NUM_ROWS) {
                    row = 0;
                    col++;
                    if (col == NUM_COLS) {
                        col = 0;
                    }
                }
            }
        }
    
        return textFields[row][col];
    }

    private void specialFocus(TextField textField){
        textField.requestFocus();
        // Clear any selection and move the caret to the end of the text
        textField.deselect();
        textField.positionCaret(textField.getText().length());
        //make caret invisible 
        textField.setStyle("-fx-caret-color: transparent;");
    }

    public ArrayList<TextField> wordStarts(){
        // find all textfields that should be start of word 
        // if there are at least two non-black cells in any direction, it is the start of a word, and should be added to array 
        // only if after a black square or top or left edge 
        // use an array list; make sure there are no duplicates, but should be in order 
        ArrayList<TextField> wordStarts=new ArrayList<TextField>();
        for (int row=0; row<NUM_ROWS; row++){
            for (int col=0; col<NUM_COLS; col++){
                if (isWordStart(row, col)&&!wordStarts.contains(textFields[row][col])){
                    wordStarts.add(textFields[row][col]);
                }
            }
        }
        return wordStarts;
    }

    public boolean isWordStart(int row, int col){
        // check if a cell is the start of a word 
        // if there is at least one non-black cell to the right or down, it is the start of a word
        if (row>=NUM_ROWS || col>=NUM_COLS){
            return false;
        } 
        if (textFields[row][col].getStyleClass().contains("black-square")){
            return false; 
        } 

        boolean horizontalStart=isHorizontalStart(row, col); 
        boolean verticalStart=isVerticalStart(row, col); 

        return horizontalStart||verticalStart;
    }

    private boolean isHorizontalStart(int row, int col){
        // check if a cell is the start of a horizontal word 
        // if there is at least one non-black cell to the right, it is the start of a word
        if (col==0||textFields[row][col-1].getStyleClass().contains("black-square")){
            if(col+1<NUM_COLS&&!textFields[row][col+1].getStyleClass().contains("black-square")){
                return true; 
            }
        }
        return false; 
    }

    private boolean isVerticalStart(int row, int col){
        // check if a cell is the start of a vertical word 
        // if there is at least one non-black cell below, it is the start of a word
        if (row==0||textFields[row-1][col].getStyleClass().contains("black-square")){
            if(row+1<NUM_ROWS&&!textFields[row+1][col].getStyleClass().contains("black-square")){
                return true; 
            }
        }
        return false; 
    }

    private ArrayList<TextField> getAcrossStarts(ArrayList<TextField> startCells){
        // get all start cells that are the start of an across word 
        ArrayList<TextField> acrossStarts=new ArrayList<TextField>();
        for (TextField textField : startCells){
            StackPane parentNode=(StackPane)textField.getParent();
            int row=GridPane.getRowIndex(parentNode);
            int col=GridPane.getColumnIndex(parentNode);
            if (isHorizontalStart(row, col)){
                acrossStarts.add(textField);
            }
        }
        return acrossStarts; 
    }

    private ArrayList<TextField> getDownStarts(ArrayList<TextField> startCells){
        // get all start cells that are the start of a down word 
        ArrayList<TextField> downStarts=new ArrayList<TextField>();
        for (TextField textField : startCells){
            StackPane parentNode=(StackPane)textField.getParent();
            int row=GridPane.getRowIndex(parentNode);
            int col=GridPane.getColumnIndex(parentNode);
            if (isVerticalStart(row, col)){
                downStarts.add(textField);
            }
        }
        return downStarts; 
    }

    private void labelStartCells(){
        // label all start cells with numbers 
        // get all start cells 
        ArrayList<TextField> startCells=wordStarts(); 
        int count=1; 
        for (TextField textField : startCells){
            StackPane parentNode=(StackPane)textField.getParent();
            int row=GridPane.getRowIndex(parentNode);
            int col=GridPane.getColumnIndex(parentNode);
                    Label numberLabel = new Label(String.valueOf(count));
                    numberLabel.getStyleClass().add("number-label");
                    numberLabel.setTranslateX(-15);
                    numberLabel.setTranslateY(-15);
                    parentNode.getChildren().add(numberLabel);
                    cellNumbers[row][col] = count;
                    //if there's new number, add to across or down clues
                    if (!acrossClues.containsKey(count)){
                        if (isHorizontalStart(row, col)){
                            acrossClues.put(count, "");
                        }
                        if (isVerticalStart(row, col)){
                            downClues.put(count, ""); 
                        }
                    }
                    count++; 
        }

    }

    private void clearLabels(){
        // clear all labels from board 
        for (int i=0; i<NUM_ROWS; i++){
            for (int j=0; j<NUM_COLS; j++){
                StackPane parentNode=(StackPane)textFields[i][j].getParent();
                parentNode.getChildren().removeIf(node -> node instanceof Label);
            }
        }
    }

    private void setUpClueView(){
        // set up clue maps 
        clearHints(); 
        // get all across and down starts
        ArrayList<TextField> startCells=wordStarts();
        ArrayList<TextField> acrossStarts=getAcrossStarts(startCells);
        ArrayList<TextField> downStarts=getDownStarts(startCells);

        // clear all clues
        acrossClues.clear();
        downClues.clear();

        // add across to acrossClues map with correct number (check cellNumbers)
        // get clue from grid acrossHints, or make empty string 
        for (TextField textField : acrossStarts){
            StackPane parentNode=(StackPane)textField.getParent();
            int row=GridPane.getRowIndex(parentNode);
            int col=GridPane.getColumnIndex(parentNode);
            int number=cellNumbers[row][col];
            if (grid.getAcrossHints().containsKey(number)){
                acrossClues.put(number, grid.getAcrossHints().get(number));
            } else {
                acrossClues.put(number, ""); 
            }
        }

        // add down to downClues map with correct number (check cellNumbers)
        // get clue from grid downHints, or make empty string
        for (TextField textField : downStarts){
            StackPane parentNode=(StackPane)textField.getParent();
            int row=GridPane.getRowIndex(parentNode);
            int col=GridPane.getColumnIndex(parentNode);
            int number=cellNumbers[row][col];
            if (grid.getDownHints().containsKey(number)){
                downClues.put(number, grid.getDownHints().get(number));
            } else {
                downClues.put(number, ""); 
            } 
        }

        TextFlow acrossTextFlow = new TextFlow();
        TextFlow downTextFlow = new TextFlow();

        for (Map.Entry<Integer, String> entry : acrossClues.entrySet()) {
            acrossTextFlow.getChildren().add(new Text(entry.getKey() + entry.getValue() + "\n"));
        }
    
        for (Map.Entry<Integer, String> entry : downClues.entrySet()) {
            downTextFlow.getChildren().add(new Text(entry.getKey() + entry.getValue() + "\n"));
        }

        ScrollPane acrossPane = new ScrollPane(acrossTextFlow);
        ScrollPane downPane = new ScrollPane(downTextFlow);

        acrossPane.setFitToWidth(true);
        downPane.setFitToWidth(true);
        acrossPane.setFitToHeight(true);
        downPane.setFitToHeight(true);
        acrossPane.setHbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);
        downPane.setHbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);
        acrossPane.setVbarPolicy(ScrollPane.ScrollBarPolicy.AS_NEEDED);
        downPane.setVbarPolicy(ScrollPane.ScrollBarPolicy.AS_NEEDED);
        acrossPane.setPrefWidth(200);
        downPane.setPrefWidth(200);
        acrossPane.setPrefHeight(200);
        downPane.setPrefHeight(200);

        clues=new HBox(acrossPane, downPane);

        while (root.getChildren().contains(clues)){
            root.getChildren().remove(clues);
        }
        root.getChildren().add(clues);

    }

    public static void main(String[] args) 
    {
        launch(args);
    }

}

